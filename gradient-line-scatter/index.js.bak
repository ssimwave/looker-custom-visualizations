looker.plugins.visualizations.add({
  id: 'gradient_line_scatter',
  label: 'Gradient Line/Scatter',
  options: {
    plot_style: {
      type: 'string',
      label: 'Plot Style',
      values: [
        {'Line': 'line'},
        {'Line with Dots': 'line_with_dots'},
        {'Dots Only': 'dots'}
      ],
      default: 'Line',
      order: 1
    },
    gradient_mode: {
      type: 'string', 
      label: 'Gradient Mode',
      display: 'select',
      values: [
        {'Auto': 'auto'},
        {'Thresholds': 'thresholds'}
      ],
      default: 'auto',
      order: 2
    },
    color_min: {
      type: 'string',
      label: 'Minimum Color',
      default: '#3b82f6',
      placeholder: '#3b82f6',
      order: 3
    },
    color_mid: {
      type: 'string',
      label: 'Midpoint Color (optional)',
      default: '',
      placeholder: 'Leave empty for linear gradient',
      order: 4
    },
    color_max: {
      type: 'string',
      label: 'Maximum Color', 
      default: '#f59e0b',
      placeholder: '#f59e0b',
      order: 5
    },
    t_low: {
      type: 'number',
      label: 'Low Threshold',
      default: 0,
      order: 6
    },
    t_high: {
      type: 'number',
      label: 'High Threshold', 
      default: 100,
      order: 7
    },
    line_width: {
      type: 'number',
      label: 'Line Width',
      default: 2,
      min: 0.5,
      max: 10,
      step: 0.5,
      order: 8
    },
    point_radius: {
      type: 'number',
      label: 'Point Radius',
      default: 2.5,
      min: 1,
      max: 10,
      step: 0.5,
      order: 9
    },
    show_colorbar: {
      type: 'boolean',
      label: 'Show Color Legend',
      default: true,
      order: 10
    }
  },

  create: function(element, config) {
    // Create container div
    element.innerHTML = '<div id="gradient-line-scatter"></div>';
    this.container = element.querySelector('#gradient-line-scatter');
    this.container.style.width = '100%';
    this.container.style.height = '100%';
    this.container.style.position = 'relative';
  },

  updateAsync: function(data, element, config, queryResponse, details, done) {
    try {
      this.clearError();
      
      // Validate data structure
      const validation = this.validateData(data, queryResponse);
      if (!validation.valid) {
        this.showError(validation.message);
        done();
        return;
      }

      // Process data
      const processedData = this.processData(data, queryResponse, config);
      
      // Show warnings if needed
      if (validation.warnings.length > 0) {
        this.showWarnings(validation.warnings);
      }

      // Render visualization
      this.render(processedData, config, element);
      
      done();
    } catch (error) {
      this.showError('Error rendering visualization: ' + error.message);
      done();
    }
  },

  validateData: function(data, queryResponse) {
    const dimensions = queryResponse.fields.dimension_like;
    const measures = queryResponse.fields.measure_like;
    const pivots = queryResponse.fields.pivots || [];
    
    const warnings = [];
    
    // Check for pivots
    if (pivots.length > 0) {
      return {
        valid: false,
        message: 'This visualization does not support pivoted data. Please remove pivots from your query.',
        warnings: []
      };
    }
    
    // Check dimensions
    if (dimensions.length === 0) {
      return {
        valid: false,
        message: 'This visualization requires exactly one dimension for the x-axis.',
        warnings: []
      };
    }
    
    if (dimensions.length > 1) {
      warnings.push('Multiple dimensions detected. Only the first dimension will be used for the x-axis.');
    }
    
    // Check measures
    if (measures.length === 0) {
      return {
        valid: false,
        message: 'This visualization requires at least one measure.',
        warnings: []
      };
    }
    
    if (measures.length > 2) {
      warnings.push('More than two measures detected. Only the first two measures will be used.');
    }
    
    return {
      valid: true,
      message: '',
      warnings: warnings
    };
  },

  processData: function(data, queryResponse, config) {
    const dimensions = queryResponse.fields.dimension_like;
    const measures = queryResponse.fields.measure_like;
    
    const xField = dimensions[0].name;
    const yField = measures[0].name;
    const colorField = measures.length > 1 ? measures[1].name : yField;
    
    // Auto-detect if x-axis is time-based
    const xFieldInfo = dimensions[0];
    const isTimeField = this.isTimeField(xFieldInfo);
    
    const points = data.map(row => {
      let x = row[xField].value;
      const y = parseFloat(row[yField].value) || 0;
      const c = parseFloat(row[colorField].value) || 0;
      
      // Parse x value based on auto-detection
      if (isTimeField) {
        x = new Date(x);
        if (isNaN(x.getTime())) {
          // Try parsing common date formats
          x = this.parseDate(row[xField].value);
          if (!x) {
            x = row[xField].value; // fallback to string
          }
        }
      } else {
        const numX = parseFloat(x);
        if (!isNaN(numX)) {
          x = numX;
        }
        // else keep as string for ordinal scale
      }
      
      return { x, y, c, isTimeField };
    }).filter(d => d.y !== null && d.c !== null);
    
    // Downsample if too many points
    if (points.length > 20000) {
      const step = Math.ceil(points.length / 20000);
      return points.filter((_, i) => i % step === 0);
    }
    
    return points;
  },

  isTimeField: function(fieldInfo) {
    // Check Looker field type indicators
    const fieldType = fieldInfo.type || '';
    const fieldName = fieldInfo.name || '';
    const fieldLabel = fieldInfo.label_short || fieldInfo.label || '';
    
    // Common time field types in Looker
    const timeTypes = [
      'date', 'datetime', 'timestamp', 'time',
      'date_time', 'date_date', 'date_week', 'date_month', 
      'date_quarter', 'date_year', 'duration'
    ];
    
    // Check if field type indicates time
    if (timeTypes.some(type => fieldType.toLowerCase().includes(type))) {
      return true;
    }
    
    // Check field name patterns
    const timePatterns = [
      /date/i, /time/i, /created/i, /updated/i, /timestamp/i,
      /_at$/i, /_date$/i, /_time$/i, /year/i, /month/i, /day/i
    ];
    
    if (timePatterns.some(pattern => pattern.test(fieldName) || pattern.test(fieldLabel))) {
      return true;
    }
    
    return false;
  },

  parseDate: function(value) {
    if (!value) return null;
    
    // Try common date formats
    const formats = [
      // ISO formats
      /^\d{4}-\d{2}-\d{2}$/,
      /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/,
      // US formats
      /^\d{1,2}\/\d{1,2}\/\d{4}$/,
      /^\d{1,2}-\d{1,2}-\d{4}$/,
      // Other common formats
      /^\d{4}\/\d{2}\/\d{2}$/,
      /^\d{2}\/\d{2}\/\d{4}$/
    ];
    
    for (let format of formats) {
      if (format.test(value)) {
        const date = new Date(value);
        if (!isNaN(date.getTime())) {
          return date;
        }
      }
    }
    
    return null;
  },

  render: function(data, config, element) {
    if (data.length === 0) {
      this.showError('No data to display');
      return;
    }

    // Clear previous content
    d3.select(this.container).selectAll('*').remove();
    
    // Set up dimensions
    const margin = { 
      top: 20, 
      right: config.show_colorbar ? 100 : 20, 
      bottom: 60, 
      left: 80 
    };
    
    const containerRect = this.container.getBoundingClientRect();
    const width = containerRect.width - margin.left - margin.right;
    const height = containerRect.height - margin.top - margin.bottom;
    
    if (width <= 0 || height <= 0) return;
    
    // Create SVG
    const svg = d3.select(this.container)
      .append('svg')
      .attr('width', containerRect.width)
      .attr('height', containerRect.height)
      .style('background-color', 'transparent');
    
    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);
    
    // Set up scales
    const scales = this.createScales(data, config, width, height);
    
    // Create color scale
    const colorScale = this.createColorScale(data, config);
    
    // Create axes
    this.createAxes(g, scales, width, height);
    
    // Create tooltip
    const tooltip = this.createTooltip();
    
    // Render plot based on style
    this.renderPlot(g, data, scales, colorScale, config, tooltip);
    
    // Render colorbar
    if (config.show_colorbar) {
      this.renderColorbar(svg, colorScale, config, margin, height);
    }
  },

  createScales: function(data, config, width, height) {
    const xValues = data.map(d => d.x);
    const yValues = data.map(d => d.y);
    
    // Use the auto-detected time field information
    const isTimeField = data.length > 0 && data[0].isTimeField;
    
    let xScale;
    if (isTimeField && xValues[0] instanceof Date) {
      xScale = d3.scaleUtc()
        .domain(d3.extent(xValues))
        .range([0, width]);
    } else if (typeof xValues[0] === 'number') {
      xScale = d3.scaleLinear()
        .domain(d3.extent(xValues))
        .range([0, width]);
    } else {
      xScale = d3.scalePoint()
        .domain(xValues.map(String))
        .range([0, width])
        .padding(0.1);
    }
    
    const yScale = d3.scaleLinear()
      .domain(d3.extent(yValues))
      .nice()
      .range([height, 0]);
    
    return { xScale, yScale };
  },

  createColorScale: function(data, config) {
    const colorValues = data.map(d => d.c);
    const colorMin = config.color_min || '#3b82f6';
    const colorMax = config.color_max || '#f59e0b';
    const colorMid = config.color_mid || '';
    
    let domain, range;
    
    if (config.gradient_mode === 'thresholds') {
      if (colorMid) {
        domain = [config.t_low, (config.t_low + config.t_high) / 2, config.t_high];
        range = [colorMin, colorMid, colorMax];
        return d3.scaleLinear().domain(domain).range(range);
      } else {
        domain = [config.t_low, config.t_high];
        range = [colorMin, colorMax];
        return d3.scaleLinear().domain(domain).range(range);
      }
    } else {
      const extent = d3.extent(colorValues);
      if (colorMid) {
        domain = [extent[0], (extent[0] + extent[1]) / 2, extent[1]];
        range = [colorMin, colorMid, colorMax];
        return d3.scaleLinear().domain(domain).range(range);
      } else {
        domain = extent;
        range = [colorMin, colorMax];
        return d3.scaleLinear().domain(domain).range(range);
      }
    }
  },

  createAxes: function(g, scales, width, height) {
    // Create gridlines
    g.append('g')
      .attr('class', 'grid')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(scales.xScale)
        .tickSize(-height)
        .tickFormat('')
      )
      .style('stroke-dasharray', '3,3')
      .style('opacity', 0.3);
    
    g.append('g')
      .attr('class', 'grid')
      .call(d3.axisLeft(scales.yScale)
        .tickSize(-width)
        .tickFormat('')
      )
      .style('stroke-dasharray', '3,3')
      .style('opacity', 0.3);
    
    // Create axes
    g.append('g')
      .attr('class', 'x-axis')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(scales.xScale))
      .style('color', '#e5e7eb');
    
    g.append('g')
      .attr('class', 'y-axis')
      .call(d3.axisLeft(scales.yScale))
      .style('color', '#e5e7eb');
    
    // Style axes
    g.selectAll('.domain, .tick line')
      .style('stroke', '#6b7280');
    
    g.selectAll('.tick text')
      .style('fill', '#e5e7eb');
  },

  createTooltip: function() {
    return d3.select('body').append('div')
      .attr('class', 'gradient-tooltip')
      .style('position', 'absolute')
      .style('background', 'rgba(0, 0, 0, 0.8)')
      .style('color', 'white')
      .style('padding', '8px')
      .style('border-radius', '4px')
      .style('font-size', '12px')
      .style('pointer-events', 'none')
      .style('opacity', 0)
      .style('z-index', 1000);
  },

  renderPlot: function(g, data, scales, colorScale, config, tooltip) {
    const lineWidth = config.line_width || 2;
    const pointRadius = config.point_radius || 2.5;
    
    // Render lines
    if (config.plot_style === 'line' || config.plot_style === 'line_with_dots') {
      this.renderLines(g, data, scales, colorScale, lineWidth);
    }
    
    // Render points
    if (config.plot_style === 'dots' || config.plot_style === 'line_with_dots') {
      this.renderPoints(g, data, scales, colorScale, pointRadius, tooltip);
    }
  },

  renderLines: function(g, data, scales, colorScale, lineWidth) {
    const lineGroup = g.append('g').attr('class', 'lines');
    
    for (let i = 0; i < data.length - 1; i++) {
      const d1 = data[i];
      const d2 = data[i + 1];
      
      // Average color for segment
      const avgColor = colorScale((d1.c + d2.c) / 2);
      
      lineGroup.append('line')
        .attr('x1', scales.xScale(d1.x))
        .attr('y1', scales.yScale(d1.y))
        .attr('x2', scales.xScale(d2.x))
        .attr('y2', scales.yScale(d2.y))
        .attr('stroke', avgColor)
        .attr('stroke-width', lineWidth)
        .attr('stroke-linecap', 'round');
    }
  },

  renderPoints: function(g, data, scales, colorScale, pointRadius, tooltip) {
    g.selectAll('.point')
      .data(data)
      .enter()
      .append('circle')
      .attr('class', 'point')
      .attr('cx', d => scales.xScale(d.x))
      .attr('cy', d => scales.yScale(d.y))
      .attr('r', pointRadius)
      .attr('fill', d => colorScale(d.c))
      .attr('stroke', 'white')
      .attr('stroke-width', 0.5)
      .style('cursor', 'pointer')
      .on('mouseover', function(event, d) {
        tooltip.transition().duration(200).style('opacity', 1);
        tooltip.html(`X: ${d.x}<br/>Y: ${d.y}<br/>Color: ${d.c}`)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 10) + 'px');
      })
      .on('mouseout', function() {
        tooltip.transition().duration(500).style('opacity', 0);
      });
  },

  renderColorbar: function(svg, colorScale, config, margin, height) {
    const colorbarWidth = 20;
    const colorbarHeight = height * 0.8;
    const colorbarX = margin.left + margin.right + colorbarWidth;
    const colorbarY = margin.top + (height - colorbarHeight) / 2;
    
    // Create gradient definition
    const defs = svg.append('defs');
    const gradient = defs.append('linearGradient')
      .attr('id', 'colorbar-gradient')
      .attr('x1', '0%')
      .attr('y1', '100%')
      .attr('x2', '0%')
      .attr('y2', '0%');
    
    const domain = colorScale.domain();
    const range = colorScale.range();
    
    if (domain.length === 3) {
      gradient.append('stop')
        .attr('offset', '0%')
        .attr('stop-color', range[0]);
      gradient.append('stop')
        .attr('offset', '50%')
        .attr('stop-color', range[1]);
      gradient.append('stop')
        .attr('offset', '100%')
        .attr('stop-color', range[2]);
    } else {
      gradient.append('stop')
        .attr('offset', '0%')
        .attr('stop-color', range[0]);
      gradient.append('stop')
        .attr('offset', '100%')
        .attr('stop-color', range[1]);
    }
    
    // Draw colorbar
    svg.append('rect')
      .attr('x', colorbarX)
      .attr('y', colorbarY)
      .attr('width', colorbarWidth)
      .attr('height', colorbarHeight)
      .style('fill', 'url(#colorbar-gradient)')
      .style('stroke', '#6b7280');
    
    // Add scale
    const colorbarScale = d3.scaleLinear()
      .domain(domain.length === 3 ? [domain[0], domain[2]] : domain)
      .range([colorbarY + colorbarHeight, colorbarY]);
    
    svg.append('g')
      .attr('transform', `translate(${colorbarX + colorbarWidth + 5}, 0)`)
      .call(d3.axisRight(colorbarScale).ticks(5))
      .style('color', '#e5e7eb')
      .selectAll('text')
      .style('fill', '#e5e7eb');
  },

  showError: function(message) {
    this.container.innerHTML = `
      <div style="
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #ef4444;
        font-size: 14px;
        text-align: center;
        padding: 20px;
      ">
        ${message}
      </div>
    `;
  },

  showWarnings: function(warnings) {
    const warningDiv = document.createElement('div');
    warningDiv.style.cssText = `
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(251, 191, 36, 0.9);
      color: #1f2937;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
      max-width: 300px;
    `;
    warningDiv.innerHTML = warnings.map(w => `⚠️ ${w}`).join('<br>');
    this.container.appendChild(warningDiv);
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      if (warningDiv.parentNode) {
        warningDiv.parentNode.removeChild(warningDiv);
      }
    }, 5000);
  },

  clearError: function() {
    // Remove any existing error messages
    const existingErrors = this.container.querySelectorAll('[style*="color: #ef4444"]');
    existingErrors.forEach(el => el.remove());
    
    // Remove any existing warnings
    const existingWarnings = this.container.querySelectorAll('[style*="background: rgba(251, 191, 36"]');
    existingWarnings.forEach(el => el.remove());
  }
});